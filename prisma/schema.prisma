generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

// ============================================================================
// HELIOS ERP TABLES (Simulated in dev, Real in production)
// ============================================================================

// TabCisZam - Helios ERP Employee Master Table
//
// ARCHITECTURE (IDENTICAL in DEV and PROD):
//   - Development: Simulated Helios table created by dev-db-full-setup.sql
//   - Production: Physical Helios ERP table (READ-ONLY for AeroLMS)
//   - Both environments use exact same structure
//
// USAGE IN APPLICATION:
//   - ‚ùå NOT used directly by application code
//   - ‚úÖ Data accessed via User SYNONYM ‚Üí InspiritCisZam VIEW
//   - üìä Visible in Prisma Studio for development debugging
//
// FIELDS:
//   - ID: Employee unique identifier (auto-increment in Helios)
//   - Cislo: Personal employee code for login (unique)
//   - Alias: Plain text password for login (Helios ERP constraint)
//   - Jmeno, Prijmeni: Employee name from Helios HR system
//
// RELATIONS:
//   - ext: 1:1 with TabCisZam_EXT (training data)
//   - auth: 1:1 with InspiritUserAuth (AeroLMS authentication)
//   - Note: Application relations (testAttempts, certificates, etc.) are on User model
model TabCisZam {
  id       Int     @id @default(autoincrement()) @map("ID")
  cislo    Int     @unique @map("Cislo") // Personal code (employee number, for login)
  jmeno    String  @map("Jmeno") @db.NVarChar(100) // First name
  prijmeni String  @map("Prijmeni") @db.NVarChar(100) // Last name
  alias    String? @map("Alias") @db.NVarChar(255) // Plain text password (for login)

  // Relations (internal Helios structure only)
  ext  TabCisZam_EXT?
  auth InspiritUserAuth?

  @@map("TabCisZam")
}

// TabCisZam_EXT - Helios ERP Extended Table with Training Columns
//
// ARCHITECTURE (IDENTICAL in DEV and PROD):
//   - Development: Simulated Helios extended table created by dev-db-full-setup.sql
//   - Production: Physical Helios ERP table with training completion tracking
//   - Both environments use exact same structure
//
// USAGE IN APPLICATION:
//   - ‚úÖ DIRECTLY WRITTEN by updateUserTrainingData() in training-sync.ts
//   - ‚úÖ READ via InspiritCisZam VIEW (not direct table access)
//   - üîß Updates training dates after successful test completion
//
// CRITICAL SECURITY:
//   - NEVER update directly with raw SQL without validateTrainingCode()
//   - Training codes are validated to prevent SQL injection
//   - All column names have underscore prefix: _CMMDatumPosl (not CMMDatumPosl)
//
// COLUMN PATTERN (dynamic - added by DB admin):
//   ‚úÖ PHYSICAL COLUMNS in TabCisZam_EXT:
//     - _{code}DatumPosl: Last completion date (DATE)
//     - _{code}Pozadovano: Required flag (BOOLEAN, default false)
//
//   ‚úÖ COMPUTED COLUMNS in InspiritCisZam VIEW:
//     - _{code}DatumPristi: Next due date (COMPUTED via DATEADD in VIEW)
//     - Example: DATEADD(month, 24, _CMMDatumPosl) AS _CMMDatumPristi
//     - Validity period (months) set by superadmin in VIEW definition
//
// WRITE STRATEGY (IDENTICAL in DEV and PROD):
//   - Direct UPDATE to TabCisZam_EXT for DatumPosl and Pozadovano
//   - DatumPristi is READ-ONLY (auto-calculated in VIEW)
//
// IMPORTANT - DYNAMIC COLUMNS:
//   Training columns (_{code}DatumPosl, _{code}Pozadovano) are:
//   - Added dynamically by database administrator
//   - Detected at runtime via training-sync.ts (detectTrainingColumns function)
//   - NOT defined in this Prisma model to allow flexibility
//   - Accessed via raw SQL queries with validated training codes
//
// This minimal model definition allows:
//   - Prisma to recognize the table exists
//   - Runtime detection of available training columns
//   - No need to rebuild Prisma client when trainings are added/removed
model TabCisZam_EXT {
  id Int @id @map("ID")

  // Relation to TabCisZam (1:1 via ID)
  employee TabCisZam @relation(fields: [id], references: [id], onDelete: Cascade)

  @@map("TabCisZam_EXT")
}

// InspiritUserAuth - AeroLMS Authentication Table
//
// ARCHITECTURE (IDENTICAL in DEV and PROD):
//   - Physical table storing AeroLMS-specific authentication data
//   - Same structure in both environments
//
// USAGE IN APPLICATION:
//   - ‚úÖ WRITTEN via User SYNONYM ‚Üí InspiritCisZam VIEW ‚Üí INSTEAD OF triggers
//   - ‚úÖ READ via User SYNONYM ‚Üí InspiritCisZam VIEW (LEFT JOIN)
//   - üîê Stores role and email (Cislo and Alias are in TabCisZam)
//
// FIELDS:
//   - ID: Foreign key to TabCisZam.ID (1:1 relationship)
//   - role: User role (ADMIN | TRAINER | WORKER)
//   - email: Email address for admin/trainer login (optional, unique)
//   - createdAt, updatedAt: Audit timestamps
//
// WRITE FLOW (IDENTICAL in DEV and PROD):
//   Application: prisma.user.update({ email: "new@email.com" })
//        ‚Üì
//   User SYNONYM ‚Üí InspiritCisZam VIEW
//        ‚Üì
//   INSTEAD OF UPDATE trigger (dev-db-full-setup.sql or deployment/sql/03_create_inspirit_view.sql)
//        ‚Üì
//   UPDATE InspiritUserAuth SET email = ..., updatedAt = CURRENT_TIMESTAMP
//
// NOTE: Cislo (login code) and Alias (password) are in TabCisZam (Helios table)
model InspiritUserAuth {
  id        Int       @id @map("ID")
  role      String    @default("WORKER") @db.NVarChar(50)
  email     String?   @unique @db.NVarChar(255)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relation to TabCisZam (1:1 via ID)
  employee TabCisZam @relation(fields: [id], references: [id], onDelete: Cascade)

  @@index([role])
  @@map("InspiritUserAuth")
}

// ============================================================================
// AEROLMS APPLICATION TABLES
// ============================================================================

// User - Primary Application Model (Maps directly to VIEW)
//
// PURPOSE:
//   This is the MAIN model that application code uses for all user operations.
//
// ARCHITECTURE (IDENTICAL in DEV and PROD):
//   Prisma Model: User (@@map("InspiritCisZam"))
//        ‚Üì
//   VIEW: InspiritCisZam combines 3 tables via LEFT JOIN:
//       1. TabCisZam (Helios ERP - ID, Cislo, Alias, Jmeno, Prijmeni) - READ ONLY
//       2. TabCisZam_EXT (Helios ERP - training columns with _ prefix) - WRITTEN via updateUserTrainingData()
//       3. InspiritUserAuth (AeroLMS - role, email, timestamps) - WRITTEN via INSTEAD OF triggers
//
//   - Development: Simulated Helios tables (dev-db-full-setup.sql)
//   - Production: Real Helios ERP tables
//   - Database structure is IDENTICAL in both environments
//   - NO SYNONYM in database - Prisma model maps directly to VIEW
//
// DATA FLOW - READ (IDENTICAL in DEV and PROD):
//   prisma.user.findMany()
//     ‚Üì
//   InspiritCisZam VIEW
//     ‚Üì
//   LEFT JOIN (TabCisZam + TabCisZam_EXT + InspiritUserAuth)
//     ‚Üì
//   Returns combined data (Cislo, Alias, Jmeno, Prijmeni, role, email, timestamps)
//
// DATA FLOW - WRITE Auth data (IDENTICAL in DEV and PROD):
//   prisma.user.update({ email: "new@email.com" })
//     ‚Üì
//   InspiritCisZam VIEW
//     ‚Üì
//   INSTEAD OF UPDATE trigger (dev-db-full-setup.sql or deployment/sql/03_create_inspirit_view.sql)
//     ‚Üì
//   UPDATE InspiritUserAuth SET email = ..., updatedAt = CURRENT_TIMESTAMP
//
// DATA FLOW - WRITE Training data (IDENTICAL in DEV and PROD):
//   updateUserTrainingData(userId, trainingCode, datumPosl)
//     ‚Üì
//   Direct UPDATE to TabCisZam_EXT (bypasses VIEW for efficiency)
//     ‚Üì
//   UPDATE TabCisZam_EXT SET _CMMDatumPosl = ..., _CMMDatumPristi = ...
//
// FIELDS MAPPING:
//   - id, cislo, firstName, lastName, alias: from TabCisZam (Helios ERP)
//   - role, email, createdAt, updatedAt: from InspiritUserAuth (AeroLMS)
//   - Training columns (_{code}DatumPosl, etc.): NOT in this model, accessed via raw SQL
//
// CRITICAL:
//   - NEVER run `prisma migrate` on production!
//   - Always use manual SQL scripts from deployment/sql/ (production) or dev-db-full-setup.sql (development)
//   - Training columns are dynamic and detected at runtime via training-sync.ts
model InspiritCisZam {
  id        Int      @id @map("ID") // Employee ID - from TabCisZam.ID
  cislo     Int?     @unique @map("Cislo") // Personal code (employee number, for login) - from TabCisZam
  firstName String   @map("Jmeno") // First name - from TabCisZam
  lastName  String   @map("Prijmeni") // Last name - from TabCisZam
  alias     String?  @map("Alias") // Plain text password (for login) - from TabCisZam
  role      String   @default("WORKER") // Role - from InspiritUserAuth
  email     String?  @unique // Email - from InspiritUserAuth
  createdAt DateTime @default(now()) // Created timestamp - from InspiritUserAuth
  updatedAt DateTime @updatedAt // Updated timestamp - from InspiritUserAuth

  testAttempts        InspiritTestAttempt[]
  trainingAssignments InspiritTrainingAssignment[]
  certificates        InspiritCertificate[]
}

// Training modules - auto-synchronized from TabCisZam_EXT columns via training-sync.ts
// Database admin adds columns with pattern: _{code}DatumPosl, _{code}DatumPristi, _{code}Pozadovano
// System detects new columns at runtime and creates corresponding Training records
model InspiritTraining {
  id                  Int                          @id @default(autoincrement())
  code                String                       @unique
  name                String
  description         String?                      @db.NVarChar(Max)
  content             String?                      @db.NVarChar(Max)
  createdAt           DateTime                     @default(now())
  updatedAt           DateTime                     @updatedAt
  deletedAt           DateTime?                    // Soft delete timestamp (NULL = active, DATE = deleted)
  tests               InspiritTest[]
  trainingAssignments InspiritTrainingAssignment[]
  certificates        InspiritCertificate[]

  @@index([deletedAt])
  @@map("InspiritTraining")
}

// Assessment tests - multiple tests per training supported
// Workers see only active tests, trainers/admins see all
// Composite index [trainingId, isActive] optimizes active tests query
model InspiritTest {
  id           Int                    @id @default(autoincrement())
  trainingId   Int
  title        String
  description  String?                @db.NVarChar(Max)
  isActive     Boolean                @default(true)
  validFrom    DateTime?
  validTo      DateTime?
  passingScore Int                    @default(75)
  timeLimit    Int?                   @default(15)
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  deletedAt    DateTime?              // Soft delete timestamp (NULL = active, DATE = deleted)
  questions    InspiritQuestion[]
  training     InspiritTraining       @relation(fields: [trainingId], references: [id])
  testAttempts InspiritTestAttempt[]

  @@index([trainingId])
  @@index([isActive])
  @@index([trainingId, isActive])
  @@index([deletedAt])
  @@map("InspiritTest")
}

// Test questions with multiple answer types (single, multiple, yes/no, text)
// Composite index [testId, order] ensures efficient ordered retrieval
model InspiritQuestion {
  id            Int            @id @default(autoincrement())
  testId        Int
  order         Int
  type          String
  question      String         @db.NVarChar(Max)
  options       String?        @db.NVarChar(Max)
  correctAnswer String?        @db.NVarChar(Max)
  points        Int            @default(1)
  required      Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  deletedAt     DateTime?      // Soft delete timestamp (NULL = active, DATE = deleted)
  test          InspiritTest   @relation(fields: [testId], references: [id])

  @@index([testId])
  @@index([testId, order])
  @@index([deletedAt])
  @@map("InspiritQuestion")
}

// User test attempts - tracks all test submissions and results
// Index [createdAt DESC] optimizes recent attempts queries
// Index [completedAt] supports filtering by completion status
model InspiritTestAttempt {
  id            Int                   @id @default(autoincrement())
  testId        Int
  userId        Int
  startedAt     DateTime              @default(now())
  completedAt   DateTime?
  score         Float?
  passed        Boolean?
  answers       String?               @db.NVarChar(Max)
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  deletedAt     DateTime?             // Soft delete timestamp (NULL = active, DATE = deleted)
  test          InspiritTest          @relation(fields: [testId], references: [id])
  user          InspiritCisZam        @relation(fields: [userId], references: [id])
  certificates  InspiritCertificate[]

  @@index([userId])
  @@index([testId])
  @@index([userId, testId])
  @@index([createdAt(sort: Desc)])
  @@index([completedAt])
  @@index([deletedAt])
  @@map("InspiritTestAttempt")
}

// PDF certificates for completed trainings - generated on successful test completion
// Index [validUntil] supports expiration queries and renewal notifications
// Index [certificateNumber] enables fast lookup by certificate number
model InspiritCertificate {
  id                Int                   @id @default(autoincrement())
  userId            Int
  trainingId        Int
  testAttemptId     Int                   @unique
  certificateNumber String                @unique
  issuedAt          DateTime              @default(now())
  validUntil        DateTime
  pdfData           String?               @db.NVarChar(Max)
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  deletedAt         DateTime?             // Soft delete timestamp (NULL = active, DATE = deleted) - preserves legal documents

  user              InspiritCisZam        @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  training          InspiritTraining      @relation(fields: [trainingId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  testAttempt       InspiritTestAttempt   @relation(fields: [testAttemptId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([trainingId])
  @@index([certificateNumber])
  @@index([validUntil])
  @@index([deletedAt])
  @@map("InspiritCertificate")
}

model InspiritTrainingAssignment {
  id         Int              @id @default(autoincrement())
  trainerId  Int
  trainingId Int
  assignedAt DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  deletedAt  DateTime?        // Soft delete timestamp (NULL = active, DATE = deleted)

  trainer    InspiritCisZam   @relation(fields: [trainerId], references: [id])
  training   InspiritTraining @relation(fields: [trainingId], references: [id])

  @@unique([trainerId, trainingId])
  @@index([trainerId])
  @@index([trainingId])
  @@index([deletedAt])
  @@map("InspiritTrainingAssignment")
}
